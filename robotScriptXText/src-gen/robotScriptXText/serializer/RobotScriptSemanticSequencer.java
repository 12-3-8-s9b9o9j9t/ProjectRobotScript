/*
 * generated by Xtext 2.32.0
 */
package robotScriptXText.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robotScriptModel.Add;
import robotScriptModel.And;
import robotScriptModel.AriUnOp;
import robotScriptModel.AssignVar;
import robotScriptModel.Block;
import robotScriptModel.Compare;
import robotScriptModel.DataType;
import robotScriptModel.EntryPoint;
import robotScriptModel.FunCall;
import robotScriptModel.FunctionDef;
import robotScriptModel.IfStmt;
import robotScriptModel.Linear;
import robotScriptModel.Literal;
import robotScriptModel.LoopStmt;
import robotScriptModel.Mul;
import robotScriptModel.Not;
import robotScriptModel.Or;
import robotScriptModel.ReturnStmt;
import robotScriptModel.RobotScriptModelPackage;
import robotScriptModel.Rotation;
import robotScriptModel.Sensor;
import robotScriptModel.SetSpeed;
import robotScriptModel.SimpleVarDecl;
import robotScriptModel.Speed;
import robotScriptModel.VarDeclInit;
import robotScriptModel.Variable;
import robotScriptModel.VoidType;
import robotScriptXText.services.RobotScriptGrammarAccess;

@SuppressWarnings("all")
public class RobotScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobotScriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotScriptModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotScriptModelPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case RobotScriptModelPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobotScriptModelPackage.ARI_UN_OP:
				sequence_AriUnOp(context, (AriUnOp) semanticObject); 
				return; 
			case RobotScriptModelPackage.ASSIGN_VAR:
				sequence_AssignVar(context, (AssignVar) semanticObject); 
				return; 
			case RobotScriptModelPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case RobotScriptModelPackage.COMPARE:
				sequence_Compare(context, (Compare) semanticObject); 
				return; 
			case RobotScriptModelPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case RobotScriptModelPackage.ENTRY_POINT:
				sequence_EntryPoint(context, (EntryPoint) semanticObject); 
				return; 
			case RobotScriptModelPackage.FUN_CALL:
				sequence_FunCall(context, (FunCall) semanticObject); 
				return; 
			case RobotScriptModelPackage.FUNCTION_DEF:
				sequence_FunctionDef(context, (FunctionDef) semanticObject); 
				return; 
			case RobotScriptModelPackage.IF_STMT:
				sequence_IfStmt(context, (IfStmt) semanticObject); 
				return; 
			case RobotScriptModelPackage.LINEAR:
				sequence_Linear(context, (Linear) semanticObject); 
				return; 
			case RobotScriptModelPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case RobotScriptModelPackage.LOOP_STMT:
				sequence_LoopStmt(context, (LoopStmt) semanticObject); 
				return; 
			case RobotScriptModelPackage.MUL:
				sequence_Mul(context, (Mul) semanticObject); 
				return; 
			case RobotScriptModelPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case RobotScriptModelPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobotScriptModelPackage.RETURN_STMT:
				sequence_ReturnStmt(context, (ReturnStmt) semanticObject); 
				return; 
			case RobotScriptModelPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case RobotScriptModelPackage.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case RobotScriptModelPackage.SET_SPEED:
				sequence_SetSpeed(context, (SetSpeed) semanticObject); 
				return; 
			case RobotScriptModelPackage.SIMPLE_VAR_DECL:
				sequence_SimpleVarDecl(context, (SimpleVarDecl) semanticObject); 
				return; 
			case RobotScriptModelPackage.SPEED:
				sequence_Speed(context, (Speed) semanticObject); 
				return; 
			case RobotScriptModelPackage.VAR_DECL_INIT:
				sequence_VarDeclInit(context, (VarDeclInit) semanticObject); 
				return; 
			case RobotScriptModelPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case RobotScriptModelPackage.VOID_TYPE:
				sequence_VoidType(context, (VoidType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (exprs+=Mul exprs+=Mul*)
	 * </pre>
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (exprs+=PrimaryBoolExpr exprs+=PrimaryBoolExpr*)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AriUnOp
	 *     PrimaryAriExpr returns AriUnOp
	 *     AriUnOp returns AriUnOp
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_AriUnOp(ISerializationContext context, AriUnOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_UN_OP__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_UN_OP__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAriUnOpAccess().getExprExpressionParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns AssignVar
	 *     AssignVar returns AssignVar
	 *
	 * Constraint:
	 *     (var=[VarDecl|EString] expr=Expression)
	 * </pre>
	 */
	protected void sequence_AssignVar(ISerializationContext context, AssignVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ASSIGN_VAR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ASSIGN_VAR__VAR));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ASSIGN__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ASSIGN__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignVarAccess().getVarVarDeclEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotScriptModelPackage.Literals.ASSIGN_VAR__VAR, false));
		feeder.accept(grammarAccess.getAssignVarAccess().getExprExpressionParserRuleCall_5_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (stmts+=Statement stmts+=Statement*)?
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Compare
	 *     PrimaryBoolExpr returns Compare
	 *     Compare returns Compare
	 *
	 * Constraint:
	 *     (exprs+=Add exprs+=Add*)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, Compare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnyType returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     {DataType}
	 * </pre>
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EntryPoint returns EntryPoint
	 *
	 * Constraint:
	 *     (functions+=FunctionDef functions+=FunctionDef*)?
	 * </pre>
	 */
	protected void sequence_EntryPoint(ISerializationContext context, EntryPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FunCall
	 *     Expression returns FunCall
	 *     PrimaryAriExpr returns FunCall
	 *     FunCall returns FunCall
	 *
	 * Constraint:
	 *     (fun=[FunctionDef|EString] (inputs+=Expression inputs+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_FunCall(ISerializationContext context, FunCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionDef returns FunctionDef
	 *
	 * Constraint:
	 *     (name=EString returnType=AnyType block=Block (inputs+=SimpleVarDecl inputs+=SimpleVarDecl*)?)
	 * </pre>
	 */
	protected void sequence_FunctionDef(ISerializationContext context, FunctionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IfStmt
	 *     IfStmt returns IfStmt
	 *
	 * Constraint:
	 *     (expr=Expression ifstmt=Statement elsestmt=Statement?)
	 * </pre>
	 */
	protected void sequence_IfStmt(ISerializationContext context, IfStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Linear
	 *     Linear returns Linear
	 *
	 * Constraint:
	 *     (unit=Unit? expr=Expression)
	 * </pre>
	 */
	protected void sequence_Linear(ISerializationContext context, Linear semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Literal
	 *     PrimaryAriExpr returns Literal
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     {Literal}
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LoopStmt
	 *     LoopStmt returns LoopStmt
	 *
	 * Constraint:
	 *     (expr=Expression stmt=Statement)
	 * </pre>
	 */
	protected void sequence_LoopStmt(ISerializationContext context, LoopStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.LOOP_STMT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.LOOP_STMT__EXPR));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.LOOP_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.LOOP_STMT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopStmtAccess().getExprExpressionParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.accept(grammarAccess.getLoopStmtAccess().getStmtStatementParserRuleCall_5_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Mul
	 *     Mul returns Mul
	 *
	 * Constraint:
	 *     (exprs+=PrimaryAriExpr exprs+=PrimaryAriExpr*)
	 * </pre>
	 */
	protected void sequence_Mul(ISerializationContext context, Mul semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Not
	 *     PrimaryBoolExpr returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     expr=Compare
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.NOT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.NOT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getExprCompareParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (exprs+=And exprs+=And*)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ReturnStmt
	 *     ReturnStmt returns ReturnStmt
	 *
	 * Constraint:
	 *     expr=Expression?
	 * </pre>
	 */
	protected void sequence_ReturnStmt(ISerializationContext context, ReturnStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.MOVEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.MOVEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotationAccess().getExprExpressionParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Sensor
	 *     PrimaryAriExpr returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     {Sensor}
	 * </pre>
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetSpeed
	 *     SetSpeed returns SetSpeed
	 *
	 * Constraint:
	 *     (unit=Unit? expr=Expression speed=Speed)
	 * </pre>
	 */
	protected void sequence_SetSpeed(ISerializationContext context, SetSpeed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SimpleVarDecl
	 *     VarDecl returns SimpleVarDecl
	 *     SimpleVarDecl returns SimpleVarDecl
	 *
	 * Constraint:
	 *     (name=EString type=DataType)
	 * </pre>
	 */
	protected void sequence_SimpleVarDecl(ISerializationContext context, SimpleVarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleVarDeclAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSimpleVarDeclAccess().getTypeDataTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Speed
	 *     PrimaryAriExpr returns Speed
	 *     Speed returns Speed
	 *
	 * Constraint:
	 *     {Speed}
	 * </pre>
	 */
	protected void sequence_Speed(ISerializationContext context, Speed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns VarDeclInit
	 *     VarDecl returns VarDeclInit
	 *     VarDeclInit returns VarDeclInit
	 *
	 * Constraint:
	 *     (name=EString type=DataType expr=Expression)
	 * </pre>
	 */
	protected void sequence_VarDeclInit(ISerializationContext context, VarDeclInit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__TYPE));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL_INIT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL_INIT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclInitAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDeclInitAccess().getTypeDataTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarDeclInitAccess().getExprExpressionParserRuleCall_6_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Variable
	 *     PrimaryAriExpr returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     var=[VarDecl|EString]
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VARIABLE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VARIABLE__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getVarVarDeclEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotScriptModelPackage.Literals.VARIABLE__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnyType returns VoidType
	 *     VoidType returns VoidType
	 *
	 * Constraint:
	 *     {VoidType}
	 * </pre>
	 */
	protected void sequence_VoidType(ISerializationContext context, VoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
