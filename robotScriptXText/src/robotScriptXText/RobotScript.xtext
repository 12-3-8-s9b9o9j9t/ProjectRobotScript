// automatically generated by Xtext
grammar robotScriptXText.RobotScript with org.eclipse.xtext.common.Terminals

import "http://www.example.org/robotScriptModel" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

EntryPoint:
	(funs+=FunDef)*
;

FunDef:
	type=AnyType name=ID '(' (params+=SimpleVarDecl ( ',' params+=SimpleVarDecl)* )? ')' body=Block
;

AnyType:
	VoidType | DataType
;

VoidType:
	name='void'
;

DataType:
	name=('bool' | 'number')
;

/*VarDecl returns VarDecl:
	SimpleVarDecl | VarDeclInit
;*/

SimpleVarDecl:
	type=DataType name=ID
;
	
VarDeclInit:
	type=DataType name=ID '=' expr=Expression
;

Expression:
	Or
;

Or returns Expression:
	And ({BinExpr.expr1=current} op='||' expr2=And)*
;
	
And returns Expression:
	PrimBoolExpr ({BinExpr.expr1=current} op='&&' expr2=PrimBoolExpr)*
;

PrimBoolExpr returns Expression:
	Not | Compare
;

Not returns UnExpr:
	op='!' expr=Expression
;

Compare returns Expression:
	Add ({BinExpr.expr1=current} op=('=='|'!='|'<='|'>='|'<'|'>') expr2=Add)*
;

Add returns Expression:
	Mul ({BinExpr.expr1=current} op=('+'|'-') expr2=Mul)*
;

Mul returns Expression:
	PrimExpr ({BinExpr.expr1=current} op=('*'|'/') expr2=PrimExpr)*
;

PrimExpr returns Expression:
	Neg | Group | Lit | Ref | FunCall | GetSpeed | Distance | Time
;

Neg returns UnExpr:
	op='-' expr=Expression
;

Group returns Expression:
	'(' Expression ')'
;

Lit:
	val=INT
;

Ref:
	val=[VarDecl]
;

GetSpeed:
	{GetSpeed}
	'Speed' (unit=UnitCast)?
;

Distance:
	{Distance}
	'Distance' (unit=UnitCast)?
;

Time:
	{Time}
	'Time'
;

FunCall:
	fun=[FunDef] '(' (params+=Expression ( ',' params+=Expression)* )? ')'
;

Block:
	{Block}
	'{' (stmts+=Statement)*	'}'
;

Statement:
	Block | SimpleVarDecl | VarDeclInit | AssignVar | SetSpeed | FunCall | WhileStmt | IfStmt | ReturnStmt | Linear | Rotation
;

AssignVar:
	ref=[VarDecl] '=' expr=Expression
;

SetSpeed:
	'Speed' '=' expr=Expression (unit=UnitCast)?
;

WhileStmt:
    'while' '(' expr=Expression ')' stmt=Statement
;

IfStmt:
    'if' '(' expr=Expression ')' stmt1=Statement ('else' stmt2=Statement)?
;

ReturnStmt:
	{ReturnStmt}
    'return' (expr=Expression)?
;

Linear:
	dir=Direction expr=Expression (unit=UnitCast)?
;

Rotation:
	'Rotate' expr=Expression
;

UnitCast:
	'in' unit=Unit
;

enum Unit:
				m = 'm' | dm = 'dm' | cm = 'cm' | mm = 'mm';

enum Direction:
				Forward = 'Forward' | Sideways = 'Sideways';
