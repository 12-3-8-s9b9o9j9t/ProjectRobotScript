/*
 * generated by Xtext 2.32.0
 */
package robotScript.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robotScript.services.RobotScriptGrammarAccess;
import robotScriptModel.Add;
import robotScriptModel.And;
import robotScriptModel.AssignAtDecl;
import robotScriptModel.Back;
import robotScriptModel.BoolLiteral;
import robotScriptModel.BooleanType;
import robotScriptModel.DistSensor;
import robotScriptModel.Div;
import robotScriptModel.EntryPoint;
import robotScriptModel.Equ;
import robotScriptModel.Front;
import robotScriptModel.FunCall;
import robotScriptModel.FunctionDef;
import robotScriptModel.GEq;
import robotScriptModel.Greater;
import robotScriptModel.If;
import robotScriptModel.IfElse;
import robotScriptModel.LEq;
import robotScriptModel.Left;
import robotScriptModel.Less;
import robotScriptModel.Loop;
import robotScriptModel.Mul;
import robotScriptModel.NEq;
import robotScriptModel.Neg;
import robotScriptModel.Not;
import robotScriptModel.NumberLiteral;
import robotScriptModel.NumberType;
import robotScriptModel.Or;
import robotScriptModel.ReAssign;
import robotScriptModel.Right;
import robotScriptModel.RobotScriptModelPackage;
import robotScriptModel.Rotation;
import robotScriptModel.SetSpeed;
import robotScriptModel.SpeedState;
import robotScriptModel.Sub;
import robotScriptModel.TimeSensor;
import robotScriptModel.VarDecl;
import robotScriptModel.Variable;
import robotScriptModel.VoidType;

@SuppressWarnings("all")
public class RobotScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobotScriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotScriptModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotScriptModelPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case RobotScriptModelPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobotScriptModelPackage.ASSIGN_AT_DECL:
				sequence_AssignAtDecl(context, (AssignAtDecl) semanticObject); 
				return; 
			case RobotScriptModelPackage.BACK:
				sequence_Back(context, (Back) semanticObject); 
				return; 
			case RobotScriptModelPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case RobotScriptModelPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case RobotScriptModelPackage.DIST_SENSOR:
				sequence_DistSensor(context, (DistSensor) semanticObject); 
				return; 
			case RobotScriptModelPackage.DIV:
				sequence_Div(context, (Div) semanticObject); 
				return; 
			case RobotScriptModelPackage.ENTRY_POINT:
				sequence_EntryPoint(context, (EntryPoint) semanticObject); 
				return; 
			case RobotScriptModelPackage.EQU:
				sequence_Equ(context, (Equ) semanticObject); 
				return; 
			case RobotScriptModelPackage.FRONT:
				sequence_Front(context, (Front) semanticObject); 
				return; 
			case RobotScriptModelPackage.FUN_CALL:
				sequence_FunCall(context, (FunCall) semanticObject); 
				return; 
			case RobotScriptModelPackage.FUNCTION_DEF:
				sequence_FunctionDef(context, (FunctionDef) semanticObject); 
				return; 
			case RobotScriptModelPackage.GEQ:
				sequence_GEq(context, (GEq) semanticObject); 
				return; 
			case RobotScriptModelPackage.GREATER:
				sequence_Greater(context, (Greater) semanticObject); 
				return; 
			case RobotScriptModelPackage.IF:
				sequence_If_Impl(context, (If) semanticObject); 
				return; 
			case RobotScriptModelPackage.IF_ELSE:
				sequence_IfElse(context, (IfElse) semanticObject); 
				return; 
			case RobotScriptModelPackage.LEQ:
				sequence_LEq(context, (LEq) semanticObject); 
				return; 
			case RobotScriptModelPackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case RobotScriptModelPackage.LESS:
				sequence_Less(context, (Less) semanticObject); 
				return; 
			case RobotScriptModelPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RobotScriptModelPackage.MUL:
				sequence_Mul(context, (Mul) semanticObject); 
				return; 
			case RobotScriptModelPackage.NEQ:
				sequence_NEq(context, (NEq) semanticObject); 
				return; 
			case RobotScriptModelPackage.NEG:
				sequence_Neg(context, (Neg) semanticObject); 
				return; 
			case RobotScriptModelPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case RobotScriptModelPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case RobotScriptModelPackage.NUMBER_TYPE:
				sequence_NumberType(context, (NumberType) semanticObject); 
				return; 
			case RobotScriptModelPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobotScriptModelPackage.RE_ASSIGN:
				sequence_ReAssign(context, (ReAssign) semanticObject); 
				return; 
			case RobotScriptModelPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			case RobotScriptModelPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case RobotScriptModelPackage.SET_SPEED:
				sequence_SetSpeed(context, (SetSpeed) semanticObject); 
				return; 
			case RobotScriptModelPackage.SPEED_STATE:
				sequence_SpeedState(context, (SpeedState) semanticObject); 
				return; 
			case RobotScriptModelPackage.SUB:
				sequence_Sub(context, (Sub) semanticObject); 
				return; 
			case RobotScriptModelPackage.TIME_SENSOR:
				sequence_TimeSensor(context, (TimeSensor) semanticObject); 
				return; 
			case RobotScriptModelPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			case RobotScriptModelPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case RobotScriptModelPackage.VOID_TYPE:
				sequence_VoidType(context, (VoidType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getAddAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getAndAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns AssignAtDecl
	 *     AssignAtDecl returns AssignAtDecl
	 *
	 * Constraint:
	 *     (expression=Expression vardecl=VarDecl)
	 * </pre>
	 */
	protected void sequence_AssignAtDecl(ISerializationContext context, AssignAtDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ASSIGN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ASSIGN__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ASSIGN_AT_DECL__VARDECL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ASSIGN_AT_DECL__VARDECL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAtDeclAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getAssignAtDeclAccess().getVardeclVarDeclParserRuleCall_5_0(), semanticObject.getVardecl());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Back
	 *     Back returns Back
	 *
	 * Constraint:
	 *     (unit=Unit? expression=Expression)
	 * </pre>
	 */
	protected void sequence_Back(ISerializationContext context, Back semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     {BoolLiteral}
	 * </pre>
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnyType returns BooleanType
	 *     DataType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 * </pre>
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns DistSensor
	 *     DistSensor returns DistSensor
	 *
	 * Constraint:
	 *     {DistSensor}
	 * </pre>
	 */
	protected void sequence_DistSensor(ISerializationContext context, DistSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Div
	 *     Div returns Div
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Div(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getDivAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EntryPoint returns EntryPoint
	 *
	 * Constraint:
	 *     (functions+=FunctionDef functions+=FunctionDef*)?
	 * </pre>
	 */
	protected void sequence_EntryPoint(ISerializationContext context, EntryPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equ
	 *     Equ returns Equ
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Equ(ISerializationContext context, Equ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEquAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getEquAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Front
	 *     Front returns Front
	 *
	 * Constraint:
	 *     (unit=Unit? expression=Expression)
	 * </pre>
	 */
	protected void sequence_Front(ISerializationContext context, Front semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns FunCall
	 *     Expression returns FunCall
	 *     FunCall returns FunCall
	 *
	 * Constraint:
	 *     (fun=[FunctionDef|EString] (inputs+=Expression inputs+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_FunCall(ISerializationContext context, FunCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionDef returns FunctionDef
	 *
	 * Constraint:
	 *     (name=EString returnType=AnyType (body+=Command body+=Command*)? (inputs+=VarDecl inputs+=VarDecl*)?)
	 * </pre>
	 */
	protected void sequence_FunctionDef(ISerializationContext context, FunctionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GEq
	 *     GEq returns GEq
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_GEq(ISerializationContext context, GEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGEqAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getGEqAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Greater
	 *     Greater returns Greater
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Greater(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreaterAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getGreaterAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns IfElse
	 *     IfElse returns IfElse
	 *
	 * Constraint:
	 *     ((body+=Command body+=Command*)? cond=Expression (bodyElse+=Command bodyElse+=Command*)?)
	 * </pre>
	 */
	protected void sequence_IfElse(ISerializationContext context, IfElse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns If
	 *     If_Impl returns If
	 *
	 * Constraint:
	 *     ((body+=Command body+=Command*)? cond=Expression)
	 * </pre>
	 */
	protected void sequence_If_Impl(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LEq
	 *     LEq returns LEq
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_LEq(ISerializationContext context, LEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLEqAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getLEqAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Left
	 *     Left returns Left
	 *
	 * Constraint:
	 *     (unit=Unit? expression=Expression)
	 * </pre>
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Less
	 *     Less returns Less
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Less(ISerializationContext context, Less semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLessAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getLessAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     ((body+=Command body+=Command*)? cond=Expression)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Mul
	 *     Mul returns Mul
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Mul(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getMulAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NEq
	 *     NEq returns NEq
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_NEq(ISerializationContext context, NEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNEqAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getNEqAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Neg
	 *     Neg returns Neg
	 *
	 * Constraint:
	 *     op=Expression
	 * </pre>
	 */
	protected void sequence_Neg(ISerializationContext context, Neg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.UN_OP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.UN_OP__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegAccess().getOpExpressionParserRuleCall_3_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     op=Expression
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.UN_OP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.UN_OP__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getOpExpressionParserRuleCall_3_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     {NumberLiteral}
	 * </pre>
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnyType returns NumberType
	 *     DataType returns NumberType
	 *     NumberType returns NumberType
	 *
	 * Constraint:
	 *     {NumberType}
	 * </pre>
	 */
	protected void sequence_NumberType(ISerializationContext context, NumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getOrAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns ReAssign
	 *     ReAssign returns ReAssign
	 *
	 * Constraint:
	 *     (var=[VarDecl|EString] expression=Expression)
	 * </pre>
	 */
	protected void sequence_ReAssign(ISerializationContext context, ReAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.RE_ASSIGN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.RE_ASSIGN__VAR));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ASSIGN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ASSIGN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReAssignAccess().getVarVarDeclEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotScriptModelPackage.Literals.RE_ASSIGN__VAR, false));
		feeder.accept(grammarAccess.getReAssignAccess().getExpressionExpressionParserRuleCall_5_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Right
	 *     Right returns Right
	 *
	 * Constraint:
	 *     (unit=Unit? expression=Expression)
	 * </pre>
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     expression=Expression
	 * </pre>
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.MOVEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.MOVEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotationAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns SetSpeed
	 *     SetSpeed returns SetSpeed
	 *
	 * Constraint:
	 *     (unit=Unit? speedstate=[SpeedState|EString] expression=Expression)
	 * </pre>
	 */
	protected void sequence_SetSpeed(ISerializationContext context, SetSpeed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns SpeedState
	 *     SpeedState returns SpeedState
	 *
	 * Constraint:
	 *     {SpeedState}
	 * </pre>
	 */
	protected void sequence_SpeedState(ISerializationContext context, SpeedState semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Sub
	 *     Sub returns Sub
	 *
	 * Constraint:
	 *     (rightOp=Expression leftOp=Expression)
	 * </pre>
	 */
	protected void sequence_Sub(ISerializationContext context, Sub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__RIGHT_OP));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BIN_OP__LEFT_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubAccess().getRightOpExpressionParserRuleCall_3_0(), semanticObject.getRightOp());
		feeder.accept(grammarAccess.getSubAccess().getLeftOpExpressionParserRuleCall_5_0(), semanticObject.getLeftOp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns TimeSensor
	 *     TimeSensor returns TimeSensor
	 *
	 * Constraint:
	 *     {TimeSensor}
	 * </pre>
	 */
	protected void sequence_TimeSensor(ISerializationContext context, TimeSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns VarDecl
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (name=EString type=DataType)
	 * </pre>
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__NAME));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VAR_DECL__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDeclAccess().getTypeDataTypeParserRuleCall_4_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     var=[VarDecl|EString]
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.VARIABLE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.VARIABLE__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getVarVarDeclEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotScriptModelPackage.Literals.VARIABLE__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnyType returns VoidType
	 *     VoidType returns VoidType
	 *
	 * Constraint:
	 *     {VoidType}
	 * </pre>
	 */
	protected void sequence_VoidType(ISerializationContext context, VoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
