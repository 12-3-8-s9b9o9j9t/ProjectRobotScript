/*
 * generated by Xtext 2.32.0
 */
package robotScript.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import robotScript.services.RobotScriptGrammarAccess;
import robotScriptModel.Add;
import robotScriptModel.And;
import robotScriptModel.AriLiteral;
import robotScriptModel.AriVariables;
import robotScriptModel.BoolLiteral;
import robotScriptModel.BoolVariables;
import robotScriptModel.Centi;
import robotScriptModel.Clock;
import robotScriptModel.DefVar;
import robotScriptModel.Degree;
import robotScriptModel.Linear;
import robotScriptModel.Loop;
import robotScriptModel.Meter;
import robotScriptModel.Mili;
import robotScriptModel.Model;
import robotScriptModel.Neg;
import robotScriptModel.Not;
import robotScriptModel.Or;
import robotScriptModel.RobotScriptModelPackage;
import robotScriptModel.Rotation;
import robotScriptModel.Second;
import robotScriptModel.Speed;
import robotScriptModel.Sub;
import robotScriptModel.Switch;
import robotScriptModel.UltraSound;

@SuppressWarnings("all")
public class RobotScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RobotScriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RobotScriptModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RobotScriptModelPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case RobotScriptModelPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case RobotScriptModelPackage.ARI_LITERAL:
				sequence_AriLiteral(context, (AriLiteral) semanticObject); 
				return; 
			case RobotScriptModelPackage.ARI_VARIABLES:
				sequence_AriVariables(context, (AriVariables) semanticObject); 
				return; 
			case RobotScriptModelPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case RobotScriptModelPackage.BOOL_VARIABLES:
				sequence_BoolVariables(context, (BoolVariables) semanticObject); 
				return; 
			case RobotScriptModelPackage.CENTI:
				sequence_Centi(context, (Centi) semanticObject); 
				return; 
			case RobotScriptModelPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case RobotScriptModelPackage.DEF_VAR:
				sequence_DefVar(context, (DefVar) semanticObject); 
				return; 
			case RobotScriptModelPackage.DEGREE:
				sequence_Degree(context, (Degree) semanticObject); 
				return; 
			case RobotScriptModelPackage.LINEAR:
				sequence_Linear(context, (Linear) semanticObject); 
				return; 
			case RobotScriptModelPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case RobotScriptModelPackage.METER:
				sequence_Meter(context, (Meter) semanticObject); 
				return; 
			case RobotScriptModelPackage.MILI:
				sequence_Mili(context, (Mili) semanticObject); 
				return; 
			case RobotScriptModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RobotScriptModelPackage.NEG:
				sequence_Neg(context, (Neg) semanticObject); 
				return; 
			case RobotScriptModelPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case RobotScriptModelPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case RobotScriptModelPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case RobotScriptModelPackage.SECOND:
				sequence_Second(context, (Second) semanticObject); 
				return; 
			case RobotScriptModelPackage.SPEED:
				sequence_Speed(context, (Speed) semanticObject); 
				return; 
			case RobotScriptModelPackage.SUB:
				sequence_Sub(context, (Sub) semanticObject); 
				return; 
			case RobotScriptModelPackage.SWITCH:
				sequence_Switch(context, (Switch) semanticObject); 
				return; 
			case RobotScriptModelPackage.ULTRA_SOUND:
				sequence_UltraSound(context, (UltraSound) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expressions returns Add
	 *     Arithmetic returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (right=Arithmetic left=Arithmetic)
	 * </pre>
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__RIGHT));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddAccess().getRightArithmeticParserRuleCall_3_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getAddAccess().getLeftArithmeticParserRuleCall_5_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Boolean returns And
	 *     Expressions returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (left=Boolean right=Boolean)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getLeftBooleanParserRuleCall_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightBooleanParserRuleCall_5_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expressions returns AriLiteral
	 *     Arithmetic returns AriLiteral
	 *     AriLiteral returns AriLiteral
	 *
	 * Constraint:
	 *     units=Units?
	 * </pre>
	 */
	protected void sequence_AriLiteral(ISerializationContext context, AriLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expressions returns AriVariables
	 *     Arithmetic returns AriVariables
	 *     AriVariables returns AriVariables
	 *
	 * Constraint:
	 *     reference=[DefVar|EString]
	 * </pre>
	 */
	protected void sequence_AriVariables(ISerializationContext context, AriVariables semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_VARIABLES__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_VARIABLES__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAriVariablesAccess().getReferenceDefVarEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotScriptModelPackage.Literals.ARI_VARIABLES__REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Boolean returns BoolLiteral
	 *     Expressions returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     {BoolLiteral}
	 * </pre>
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Boolean returns BoolVariables
	 *     Expressions returns BoolVariables
	 *     BoolVariables returns BoolVariables
	 *
	 * Constraint:
	 *     reference=[DefVar|EString]
	 * </pre>
	 */
	protected void sequence_BoolVariables(ISerializationContext context, BoolVariables semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BOOL_VARIABLES__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BOOL_VARIABLES__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolVariablesAccess().getReferenceDefVarEStringParserRuleCall_3_0_1(), semanticObject.eGet(RobotScriptModelPackage.Literals.BOOL_VARIABLES__REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Prefix returns Centi
	 *     Centi returns Centi
	 *
	 * Constraint:
	 *     {Centi}
	 * </pre>
	 */
	protected void sequence_Centi(ISerializationContext context, Centi semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Clock
	 *     Clock returns Clock
	 *
	 * Constraint:
	 *     (defvar+=Command defvar+=Command*)
	 * </pre>
	 */
	protected void sequence_Clock(ISerializationContext context, Clock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns DefVar
	 *     DefVar returns DefVar
	 *
	 * Constraint:
	 *     (name=EString expressions=Expressions units=Units?)
	 * </pre>
	 */
	protected void sequence_DefVar(ISerializationContext context, DefVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Units returns Degree
	 *     Degree returns Degree
	 *
	 * Constraint:
	 *     prefix=Prefix?
	 * </pre>
	 */
	protected void sequence_Degree(ISerializationContext context, Degree semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Linear
	 *     Linear returns Linear
	 *
	 * Constraint:
	 *     (defvar+=Command defvar+=Command*)
	 * </pre>
	 */
	protected void sequence_Linear(ISerializationContext context, Linear semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     (loopCondition=Boolean body+=Command body+=Command*)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Units returns Meter
	 *     Meter returns Meter
	 *
	 * Constraint:
	 *     prefix=Prefix?
	 * </pre>
	 */
	protected void sequence_Meter(ISerializationContext context, Meter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Prefix returns Mili
	 *     Mili returns Mili
	 *
	 * Constraint:
	 *     {Mili}
	 * </pre>
	 */
	protected void sequence_Mili(ISerializationContext context, Mili semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (command+=Command command+=Command*)?
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expressions returns Neg
	 *     Arithmetic returns Neg
	 *     Neg returns Neg
	 *
	 * Constraint:
	 *     operand=Arithmetic
	 * </pre>
	 */
	protected void sequence_Neg(ISerializationContext context, Neg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_UNARY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_UNARY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegAccess().getOperandArithmeticParserRuleCall_3_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Boolean returns Not
	 *     Expressions returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     operand=Boolean
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BOOL_UNARY__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BOOL_UNARY__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getOperandBooleanParserRuleCall_3_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Boolean returns Or
	 *     Expressions returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (left=Boolean right=Boolean)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.BOOL_BINARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getLeftBooleanParserRuleCall_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightBooleanParserRuleCall_5_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     (defvar+=Command defvar+=Command*)
	 * </pre>
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Units returns Second
	 *     Second returns Second
	 *
	 * Constraint:
	 *     prefix=Prefix?
	 * </pre>
	 */
	protected void sequence_Second(ISerializationContext context, Second semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Speed
	 *     Speed returns Speed
	 *
	 * Constraint:
	 *     (defvar+=Command defvar+=Command*)
	 * </pre>
	 */
	protected void sequence_Speed(ISerializationContext context, Speed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expressions returns Sub
	 *     Arithmetic returns Sub
	 *     Sub returns Sub
	 *
	 * Constraint:
	 *     (right=Arithmetic left=Arithmetic)
	 * </pre>
	 */
	protected void sequence_Sub(ISerializationContext context, Sub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__RIGHT));
			if (transientValues.isValueTransient(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RobotScriptModelPackage.Literals.ARI_BINARY__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubAccess().getRightArithmeticParserRuleCall_3_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getSubAccess().getLeftArithmeticParserRuleCall_5_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Switch
	 *     Switch returns Switch
	 *
	 * Constraint:
	 *     (switchCondition=Boolean body+=Command body+=Command*)
	 * </pre>
	 */
	protected void sequence_Switch(ISerializationContext context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns UltraSound
	 *     UltraSound returns UltraSound
	 *
	 * Constraint:
	 *     (defvar+=Command defvar+=Command*)
	 * </pre>
	 */
	protected void sequence_UltraSound(ISerializationContext context, UltraSound semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
